# read in the file(s) -- there can be multiple
# whitespace separated files, and you can
# escape new lines if necessary
read_verilog -I../../util -sv -formal -rnm dac_adc.sv maurice2022_r_string_dac.sv maurice2022_flash_adc.sv resis_div.sv

# prep does a conservative elaboration
# of the top module provided
prep -top main

# this command just does a sanity check
# of the hierarchy
hierarchy -check

# If an assumption is flopped, you might
# see strange behavior at the last state
# (because the clock hasn't toggled)
# this command ensures that assumptions
# hold at every state
chformal -assume -early

# this processes memories
# nomap means it will keep them as arrays
memory -nomap

# flatten the design hierarchy
flatten

# (optional) use an "explicit" clock
# e.g. every state is a half cycle of the
# fastest clock
# use this option if you see errors that
# refer to "adff" or asynchronous components
# IMPORTANT NOTE: the clocks are not
# automatically toggled if you use this option
clk2fflogic 
chformal -lower 
#async2sync

# (optional) uncomment and set values to simulate reset signal
# use -resetn for an active low pin
# -n configures the number of cycles to simulate
# -rstlen configures how long the reset is active (recommended to keep it active for the whole simulation)
# -w tells it to write back the final state of the simulation as the initial state in the btor2 file
# another useful option is -zinit which zero initializes any uninitialized state
#sim -clock clk -reset rst -n 1 -rstlen 1 -w main

# This turns all undriven signals into
# inputs
setundef -undriven -expose

# This writes to a file in SMV format
#write_json dac_adc.json
write_smv dac_adc.smv
#write_rtlil dac_adc.rtlil
#write_btor dac_adc.btor2
#write_smt2 dac_adc.smt2
